---
title: "How a Browser Works: A Beginner-Friendly Guide to Browser Internals"
datePublished: Thu Jan 29 2026 22:44:19 GMT+0000 (Coordinated Universal Time)
cuid: cml01k5t9000202lcbk4m02dx
slug: browser-internals
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1769726270124/d4a86612-42fa-4370-83b3-24cc12a9d46f.png
tags: browsers, web-development, chaicode

---

## Introduction

Hello readers,

Welcome to another web development blog. In the previous two blogs, I explained HTML and CSS. I hope your development journey is going smoothly.

If you are new then please read previous two blogs: 1. [HTML blog](https://iamabhishek01-webdev.hashnode.dev/html) 2. [CSS blog](https://iamabhishek01-webdev.hashnode.dev/css)

But have you ever wondered how our browser renders (displays) our HTML and CSS code? What processes does the browser follow to fetch our website from the server?

In my networking blog, I answered the question: *What happens when you type a URL and press Enter?* First, DNS resolution happens, then a connection is established, and after the HTTP request, the server serves the response. But all these things are done by the browser—so what makes the browser capable of doing this?

If you are new and want a clear understanding of networking, you can read my networking blogs here:

[Networking blogs](https://iamabhishek-networking.hashnode.dev/)

This blog is all about browser internals.

## This blog contains

1. What is browser
    
2. High level architecture of Browser
    
    * User Interface (UI)
        
    * Browser Engine
        
    * Rendering engine
        
    * Browser engine vs Rendering engine
        
    * Networking
        
    * JS interpreter
        
    * UI backend
        
    * Disk API
        
3. HTML parsing & DOM
    
4. CSS parser and CSSOM
    
5. How browser renders DOM & CSSOM
    

Let's start

## What is Browser

* Browser is a software application which is used to translate HTML into visual data.
    
* It acts as the bridge between you and the internet.
    
* If I say browser itself is mini OS, it wouldn't be wrong because it handles networking user interaction and all.
    
* Commonly used browsers are : Chrome, Firefox, Microsoft Edge, Brave etc.
    

## High level architecture of Browser

Browser is made up of components which are:

1. ### User Interface (UI):
    
    whatever you see in the browser exept the window where web page is rendered, is know as UI of browser. For example back/forward button, address bar, reload button etc. All these are part of UI.
    
2. ### Browser engine:
    
    Browsers engine is the controller of the browser. It manages:
    
    * Navigation: Back & Forward, reloads
        
    * Communication: Managing the flow between UI network layer & data storage.
        
    * Session management: it keeps the track of sessions (start and end), state across different tabs.
        
    
    In simple words browser engine is the manager of browser.
    
    Example: Blink, Chromium, gecko
    
3. ### Rendering engine
    
    * Rendering engine is responsible to make HTML content visible.
        
    * Rendering engine do the most heavy taks like creating DOM using parser,render tree, frames, layout, paint.
        
    
    It listen the command of Browser engine like reload, refresh etc.
    
    Render Engine vs Browser Engine
    
4. ### Network Layer
    
    Network component of browser handles the DNS resolution, request data from server using http/https. All the networking related task are handled by network layer.
    
5. ### JS interpreter/Engine
    
    Js interpreter is used to parse the js code. Some js engines are V8, SpiderMonkey, JavaScriptCore, chakra etc.
    
6. ### UI backend
    
    * UI backend does the actual work of displaying the HTML content in the browser by lighting up the pixels.
        
    * Rendering engine creates layout (reflow) and then in the paint process creates instructions (like create blue square of 20px width) and give it to UI backend.
        
    
    UI backend do the work of display by taking to graphic API of Os to light up the pixels.
    
7. ### Disk API (Persistent storage)
    
    * It is used to save data into cookie, local storage, session storage etc.
        
    * It also writes data into your computer's browser folder using the internal method. This internal methods (API) get triggered when js engine or networking layers need to save something.
        
    
    This is the high level overview of the browser components that what each component is responsible for.
    
    ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1769722879904/35f33b1f-7cf6-4bce-93ec-6ef2b6fc4353.png align="center")
    
    Now let's deep dive into how these components work together to display a website. I will again start from the same question **what happens when you write url on address bar and enter**?
    

As you press enter after entering URL:

1. Browser engine commands network layer to perform DNS resolution.
    
2. Network layer find the IP address of the server then connection is established. After connecting to the server network layer request data using HTTP or HTTPs.
    
3. As the first chunk (packet) of data is recieved network layer send the chunk to Rendering engine.
    
4. Now render engine send HTML bytes to tokenizer to covert bytes to tokens and then parse the chunk of HTML, even the most of the part are still travelling on network.
    

Now, it’s clear that how data fetched to brower after entering the url.

Let's build the render tree & display data. i’m explaining it step by step

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1769724615771/db6aa604-e515-4a89-b789-c445f1d98ece.png align="center")

1. ## HTML Parser & DOM
    
    * Render engine parse the HTML content using the HTML parser. This is the unconventional parse because it's unconventional behaviour HTML don't throw syntax error.
        
    
    **DOM Tree:** DOM stands for Document object model. After parsing HTML, we get the DOM nodes and with these DOM nodes DOM tree is created.
    
    ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1769723829456/6ac96825-840d-4d85-b6e0-30c98976dc20.png align="center")
    
2. ## CSS Parser & CSSOM Tree
    
    * While render engine parsing the HTML content, it gets the Link tag which is linking a CSS file then it loads the CSS file and parse CSS with CSS parser.
        
    * CSS Parser create a tree structure of CSS properties which is know as **CSSOM.**
        
    * CSSOM is also known as render-blocker, the reason will be clear ahead.
        
    
3. ## Content Sink / DOM mutation observer
    
    * You can think content sink as the collector and dispatcher. As the DOM nodes parsed, it gets the reference of that node and send that to render engine to build render tree.
        
    * Content sink is also known as DOM Mutation Observer because as the DOM gets updates it observe that and send reference of node to the rendering engine and the render tree is built again.
        
    
4. ## Render Tree
    
    * Render tree can be also called as the visual tree, which contains all the DOM nodes which is going to be displayed in the browser. For example it excludes nodes with display:none property.
        
    * It is built incrementally. It means as the Token parsed and content sink send reference to the rendering engine, render tree is created.
        
    * It is also gets updates when the CSSOM is completed and the styles are computed for each node. That's why CSSOM is known as render blocker, because render engine waits to complete CSSOM creation then after the style computation, final render tree is built.
        
    * Render tree can be rebuilt whenever DOM or CSSOM is updated.
        
    * Final render tree is = DOM nodes + Computed Style
        
    
    That's how render tree is created.
    
    ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1769724372874/fc2bd383-1650-42e2-94c7-86abb84ef61c.png align="center")
    
5. ## Render Tree vs DOM Tree
    

| **DOM Tree** | **Render Tree** |
| --- | --- |
| Created From HTML parsing | Created by matching DOM + CSSOM. |
| It has every HTML element as node | It has only element which will be painted. |
| It includes Head tag. | It doesn’t include Head. |
| It includes element with display: none | It doesn’t include element with display: none |
| Used for JS manipulation. | Used for **Layout** and **Painting**. |

Now we have completed another milestone of creating render tree. Now, we are in the final step where browser will use render tree nodes and display them into the browser. Here are the further steps:

1. ## Frame Construction
    
    After the render tree is created, the browser constructs frames. Frames do not calculate the final size or position of elements. Instead, they define how each render tree node participates in layout—whether it behaves as a block, inline, flex item, or grid item, and how it interacts with surrounding elements.
    
    **Why it exists:** It exists to create the illusion of smooth motion; the browser must "re-construct" this frame up to 60 times per second so that scrolling, animations, and interactions feel fluid rather than static or stuttery.
    
2. ## Reflow (Layout)
    
    This is the step where browser calculate the width, length and the positions (x & y), margin, padding etc. This is highest computations task performed browser in these process.
    
    It takes the frames, viewport size as input and enables geometry to each frame.
    
    In simple terms, it creates the layout of website.
    
3. ## Paint
    
    This is the second last step of rendering the website. You translate frames layout into paint instructions. In simple word, you create the instruction for the UI backend like create a blue button of 20px width.
    
4. ## UI Backend
    
    Now at the end, UI Backend comes into the picture and talk with your OS graphics API to light up the pixel in the screen.
    
    ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1769726498416/e3b6e18d-54b6-4f4b-890c-c2f19aeb23d7.png align="center")
    

Finally, our website is now visible in the web browser.

I hope I have made browser internals easy for you. It takes a lot of effort to research and explain each concept in an easy way. If this blog has taught you something, please do share it, like it, and give your feedback.

Now you understand how the browser works as well. But I know you might be getting bored of writing repetitive code. I have a solution for this, which I will share in the next blog.

Till then, stay consistent and work hard.

Peace.